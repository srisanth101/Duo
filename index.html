<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>DemoTrade — OlympTrade-style (Design by Srisanth) — WORKING</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#0f0f13;
    --panel:#111217;
    --muted:#8a8f98;
    --accent:#22c55e;
    --danger:#ff6b6b;
    --glass: rgba(255,255,255,0.03);
    --white: #eef2f6;
    --glass-2: rgba(255,255,255,0.02);
    font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#0b0b0f 0%, #0f0f13 100%);color:var(--white);-webkit-font-smoothing:antialiased;}
  .app{max-width:980px;margin:0 auto;height:100vh;display:flex;flex-direction:column;gap:10px;padding:10px;box-sizing:border-box;}
  /* header */
  .topbar{display:flex;align-items:center;justify-content:space-between;gap:8px;padding:8px 10px;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.015));border-radius:12px}
  .left{display:flex;align-items:center;gap:10px}
  .logo{width:40px;height:40px;border-radius:8px;overflow:hidden;display:flex;align-items:center;justify-content:center;background:linear-gradient(135deg,#0f1724,#10243a)}
  .logo img{width:100%;height:100%;object-fit:cover;display:block}
  .balance{display:flex;flex-direction:column;line-height:1}
  .balance .big{font-size:18px;font-weight:700}
  .balance .small{font-size:12px;color:var(--muted)}
  .right-controls{display:flex;align-items:center;gap:8px}
  .chip{background:var(--glass);padding:6px 8px;border-radius:8px;font-size:13px}
  .timeframe{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));padding:6px 8px;border-radius:8px;font-weight:600}

  /* chart area */
  .chart-wrap{flex:1;display:flex;flex-direction:column;gap:8px}
  .chart-top{display:flex;align-items:center;justify-content:space-between;padding:0 6px}
  .instrument{display:flex;align-items:center;gap:8px}
  .instrument .icon{width:44px;height:30px;border-radius:6px;background:linear-gradient(180deg,#2b2f35,#212327);display:inline-flex;align-items:center;justify-content:center;font-weight:700}
  .chart-container{background:var(--panel);border-radius:12px;padding:8px;position:relative;overflow:hidden;box-shadow:0 6px 20px rgba(0,0,0,0.6)}
  #chart{width:100%;height:100%;min-height:300px;border-radius:8px;display:block;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);}
  .y-axis{position:absolute;right:8px;top:14px;bottom:14px;display:flex;flex-direction:column;justify-content:space-between;color:var(--muted);font-size:12px;pointer-events:none}
  .countdown{position:absolute;left:50%;transform:translateX(-50%);bottom:12px;background:rgba(0,0,0,0.55);padding:6px 10px;border-radius:20px;font-weight:700;z-index:5}
  .watermark{position:absolute;left:12px;bottom:12px;font-size:11px;color:rgba(255,255,255,0.12)}
  .view-controls{position:absolute;right:12px;top:12px;display:flex;gap:6px;z-index:6}
  .small-btn{background:rgba(255,255,255,0.02);padding:6px 8px;border-radius:8px;font-weight:700;font-size:13px;cursor:pointer}

  /* bottom panel (fixed time mode) */
  .bet-panel{display:flex;flex-direction:column;gap:10px;padding:10px;background:linear-gradient(180deg, rgba(0,0,0,0.12), transparent);border-radius:12px}
  .bet-row{display:flex;gap:8px;align-items:center}
  .bet-controls{flex:1;display:flex;gap:8px;align-items:center}
  .selector{background:var(--glass-2);padding:8px 10px;border-radius:8px;font-weight:700;display:flex;gap:6px}
  .stake{display:flex;align-items:center;gap:8px;background:var(--glass-2);padding:8px;border-radius:8px}
  .stake input{background:transparent;border:0;color:var(--white);width:90px;font-weight:700;font-size:16px;outline:none}
  .btn{flex:1;padding:14px;border-radius:12px;display:flex;align-items:center;justify-content:center;font-weight:800;font-size:16px;cursor:pointer;user-select:none}
  .btn.up{background:linear-gradient(180deg,#1fbf5c,#17964a);color:#00150c}
  .btn.down{background:linear-gradient(180deg,#ff8a8a,#ff5c5c);color:#2a0404}
  .center-clock{width:64px;height:56px;border-radius:12px;background:var(--panel);display:flex;align-items:center;justify-content:center;font-weight:700}

  /* small */
  .small-muted{font-size:12px;color:var(--muted)}
  .trade-history{max-height:120px;overflow:auto;padding:8px;border-radius:8px;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.01));font-size:13px}
  .toast{position:fixed;left:50%;transform:translateX(-50%);top:18px;background:rgba(0,0,0,0.75);padding:8px 14px;border-radius:8px;z-index:1000;backdrop-filter:blur(6px)}
  .tf-btn{background:transparent;border:0;color:var(--white);font-weight:700;padding:8px 10px;border-radius:8px;cursor:pointer;opacity:0.7}
  .tf-btn.active{opacity:1;border:1px solid rgba(255,255,255,0.03)}
  .reset-view{font-size:12px;padding:6px;border-radius:8px}

  @media(max-width:520px){
    .app{padding:8px;gap:8px}
    .chart-container{padding:6px}
    .balance .big{font-size:16px}
    .center-clock{width:56px;height:56px}
    #chart{min-height:260px}
    .stake input{width:64px}
    .trade-history{max-height:80px}
  }
</style>
</head>
<body>
<div class="app" id="app">
  <div class="topbar">
    <div class="left">
      <div class="logo" title="DS Logo">
        <!-- place your logo image named ds-logo.png in the same folder -->
        <img src="ds-logo.png" alt="DS Logo" onerror="this.style.display='none'">
      </div>
      <div class="balance">
        <div class="big" id="balance">₹10,000.00</div>
        <div class="small" id="accType">Demo account</div>
      </div>
    </div>
    <div class="right-controls">
      <div class="chip instrument-select" id="instrumentChip">Asia Composite • <span style="color:var(--accent)">85%</span></div>
      <div class="timeframe" id="tickIndicator">5s</div>
    </div>
  </div>

  <div class="chart-wrap">
    <div class="chart-top">
      <div class="instrument">
        <div class="icon">AC</div>
        <div>
          <div style="font-weight:700">Asia Composite</div>
          <div class="small-muted" id="priceLabel">--</div>
        </div>
      </div>
      <div class="small-muted">Design by Srisanth</div>
    </div>

    <div class="chart-container" id="chartBox" role="region" aria-label="Candlestick chart">
      <canvas id="chart"></canvas>
      <div class="view-controls">
        <button class="small-btn" id="resetView" title="Reset view">Reset</button>
        <button class="small-btn" id="fitRight" title="Go to live">Live</button>
      </div>
      <div class="y-axis" id="yAxis"></div>
      <div class="countdown" id="countdown">00:00</div>
      <div class="watermark">Design by Srisanth</div>
    </div>
  </div>

  <div class="bet-panel">
    <div class="bet-row">
      <div class="bet-controls">
        <div class="selector" style="display:flex;gap:6px;align-items:center">
          <button id="tf1m" class="tf-btn" data-sec="60">1m</button>
          <button id="tf2m" class="tf-btn active" data-sec="120">2m</button>
          <button id="tf5m" class="tf-btn" data-sec="300">5m</button>
        </div>
        <div class="selector" id="modeBox">Fixed Time mode</div>
      </div>
      <div style="display:flex;flex-direction:column;align-items:flex-end">
        <div class="small-muted">Profit: <span id="profitPreview">+₹0.00</span></div>
        <div class="small-muted">Payout: <strong>1.9×</strong></div>
      </div>
    </div>

    <div class="bet-row" style="align-items:center;">
      <div class="stake">
        <span class="small-muted">₹</span>
        <input id="stakeInput" type="number" inputmode="numeric" value="1" min="0.1" step="0.1" />
        <div style="display:flex;flex-direction:column;font-size:12px;color:var(--muted);margin-left:8px">
          <div>Balance</div>
          <div id="balanceSmall">₹10.000.00</div>
        </div>
      </div>

      <div style="width:12px"></div>

      <div class="btn down" id="betDown">Down ↓</div>
      <div style="width:8px"></div>
      <div class="center-clock" id="clockBtn">2m</div>
      <div style="width:8px"></div>
      <div class="btn up" id="betUp">Up ↑</div>
    </div>

    <div class="trade-history" id="history">
      <strong>Bet History</strong>
      <div id="historyList"></div>
    </div>
  </div>
</div>

<div id="toastWrap" style="pointer-events:none"></div>

<script>
(function(){
  // ====== DOM refs ======
  const canvas = document.getElementById('chart');
  const box = document.getElementById('chartBox');
  const yAxis = document.getElementById('yAxis');
  const countdown = document.getElementById('countdown');
  const priceLabel = document.getElementById('priceLabel');
  const balanceEl = document.getElementById('balance');
  const balanceSmall = document.getElementById('balanceSmall');
  const stakeInput = document.getElementById('stakeInput');
  const historyList = document.getElementById('historyList');
  const toastWrap = document.getElementById('toastWrap');
  const tfButtons = document.querySelectorAll('.tf-btn');
  const tickIndicator = document.getElementById('tickIndicator');
  const resetViewBtn = document.getElementById('resetView');
  const fitRightBtn = document.getElementById('fitRight');

  // ====== state ======
  let DPR = Math.max(1, window.devicePixelRatio || 1);
  let w=0,h=0, ctx;
  let candles = []; // {t (ms), o, h, l, c}
  const candleDurationSec = 5; // candle = 5s
  const tickInterval = 5000; // 5s update
  let lastPrice = 5878.13;
  let running=true;
  let balance = 7666.00;
  let payout = 1.9;
  const betList = []; // {id,dir,stake,entryPrice,placedAt,expiry,settled,exitPrice}
  let idCounter=1;
  let selectedBetTimeSec = 120; // default 2m

  // visual controls
  let visibleCount = 80;     // number of candles visible on screen when zoom = 1
  let scaleX = 1;           // zoom multiplier (lower => more candles)
  let panOffset = 0;        // how many candles from right (0 = live)
  const panMax = () => Math.max(0, candles.length - 10);

  // ====== canvas sizing ======
  function resize(){
    DPR = Math.max(1, window.devicePixelRatio || 1);
    w = box.clientWidth;
    h = box.clientHeight;
    canvas.width = Math.floor(w * DPR);
    canvas.height = Math.floor(h * DPR);
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    ctx = canvas.getContext('2d');
    ctx.setTransform(DPR,0,0,DPR,0,0);
    draw();
  }
  window.addEventListener('resize', resize);
  resize();

  // ====== helpers ======
  function nowFloorMs(ms, sec){
    return Math.floor(ms/1000/sec) * sec * 1000;
  }
  function randWalk(p, volatility=0.002){
    const rnd = (Math.random()-0.5) * 2 * volatility;
    return +(p * (1 + rnd));
  }

  // ====== build initial candles ======
  function buildInitial(){
    candles = [];
    const count = 800;
    let t = nowFloorMs(Date.now(), candleDurationSec) - (count-1) * candleDurationSec*1000;
    let p = lastPrice;
    for(let i=0;i<count;i++){
      let open = p;
      let close = +(randWalk(open, 0.002)).toFixed(5);
      let high = +(Math.max(open,close) * (1 + Math.random()*0.0012)).toFixed(5);
      let low = +(Math.min(open,close) * (1 - Math.random()*0.0012)).toFixed(5);
      candles.push({t: t, o: +open.toFixed(5), h: high, l: low, c: close});
      p = close;
      t += candleDurationSec*1000;
    }
    lastPrice = candles[candles.length-1].c;
  }
  buildInitial();

  // ====== tick: produce a new candle every candleDurationSec (5s) ======
  function produceTick(){
    const now = Date.now();
    const start = nowFloorMs(now, candleDurationSec);
    const prev = candles[candles.length-1];
    let open = prev ? prev.c : lastPrice;
    let close = +(randWalk(open, 0.002)).toFixed(5);
    let high = Math.max(open, close) * (1 + Math.random()*0.0015);
    let low = Math.min(open, close) * (1 - Math.random()*0.0015);
    const c = {t: start, o:+open.toFixed(5), h:+high.toFixed(5), l:+low.toFixed(5), c:+close.toFixed(5)};
    candles.push(c);
    if(candles.length > 5000) candles.splice(0, candles.length-5000);
    lastPrice = c.c;

    // settle bets whose expiry <= now (use candle at or after expiry)
    for(const b of betList.filter(x=>!x.settled && x.expiry <= now)){
      const indexTime = Math.floor(b.expiry/1000/candleDurationSec) * candleDurationSec * 1000;
      const idx = candles.findIndex(x => x.t >= indexTime);
      const settleC = idx>=0 ? candles[idx] : candles[candles.length-1];
      b.exitPrice = settleC.c;
      settleBet(b);
    }

    // if we're at live view, keep panOffset = 0 (auto-follow)
    if(panOffset === 0) panOffset = 0;

    draw();
    updateUI();
  }

  // run tick every 5s
  setInterval(()=>{ if(running) produceTick(); }, tickInterval);

  // ====== UI updates ======
  function updateUI(){
    priceLabel.textContent = lastPrice.toFixed(2);
    balanceEl.textContent = 'Đ' + balance.toFixed(2);
    balanceSmall.textContent = 'Đ' + balance.toFixed(2);
    tickIndicator.textContent = candleDurationSec + 's';

    // countdown to next candle
    const now = Date.now();
    const nextCandleStart = nowFloorMs(now, candleDurationSec) + candleDurationSec*1000;
    let rem = Math.max(0, Math.floor((nextCandleStart - now)/1000));
    const mm = String(Math.floor(rem/60)).padStart(2,'0');
    const ss = String(rem%60).padStart(2,'0');

    let extra = '';
    const active = betList.filter(b=>!b.settled);
    if(active.length){
      const nextExpiry = Math.min(...active.map(b=>b.expiry));
      const r2 = Math.max(0, Math.floor((nextExpiry - now)/1000));
      const mm2 = String(Math.floor(r2/60)).padStart(2,'0');
      const ss2 = String(r2%60).padStart(2,'0');
      extra = ' • next bet: ' + mm2 + ':' + ss2;
    }
    countdown.textContent = mm + ':' + ss + extra;

    renderHistory();
  }
  // update every 1s for countdown
  setInterval(()=>{ if(running) updateUI(); }, 1000);

  // ====== Bets ======
  let placeDisabled = false;
  function placeBet(dir){
    if(placeDisabled) return;
    const stake = Math.max(0.01, parseFloat(stakeInput.value) || 0);
    if(stake > balance){ toast('Insufficient balance'); return; }
    if(stake <= 0){ toast('Enter stake'); return; }
    const entry = lastPrice;
    const placedAt = Date.now();
    const betExpiry = placedAt + selectedBetTimeSec*1000;
    const bet = { id: idCounter++, dir, stake, entryPrice: entry, placedAt, expiry: betExpiry, settled:false };
    balance -= stake; // hold stake
    betList.push(bet);
    toast('Bet placed: ' + (dir==='up'?'UP':'DOWN') + ' Đ' + stake.toFixed(2));
    // briefly disable to prevent double click spam
    placeDisabled = true;
    setTimeout(()=> placeDisabled = false, 600);
    updateUI();
    draw();
  }

  function settleBet(b){
    b.settled = true;
    b.settledAt = Date.now();
    let win = false;
    if(b.dir === 'up') win = b.exitPrice > b.entryPrice;
    else win = b.exitPrice < b.entryPrice;
    if(b.exitPrice === b.entryPrice) win = false;
    if(win){
      const payoutAmt = b.stake * payout;
      balance += payoutAmt;
      toast('WIN Đ' + (payoutAmt - b.stake).toFixed(2), 'win');
      addHistory(b, true);
    } else {
      toast('LOSS Đ' + b.stake.toFixed(2), 'loss');
      addHistory(b, false);
    }
    updateUI();
    draw();
  }

  function addHistory(b, win){
    const el = document.createElement('div');
    el.style.display='flex';
    el.style.justifyContent='space-between';
    el.style.padding='6px 0';
    el.style.borderBottom='1px solid rgba(255,255,255,0.02)';
    el.innerHTML = '<div style="color:'+ (b.dir==='up'? 'var(--accent)':'var(--danger)') +';font-weight:700">'+ (b.dir==='up'?'UP':'DOWN') +'</div>' +
                   '<div style="color:var(--muted)">'+ new Date(b.placedAt).toLocaleTimeString() +'</div>' +
                   '<div style="font-weight:700">'+ (win? ('+Đ' + ((b.stake*payout)-b.stake).toFixed(2)) : ('-Đ' + b.stake.toFixed(2))) +'</div>';
    historyList.prepend(el);
  }

  function renderHistory(){
    // history DOM is managed by addHistory; we could add active bets preview here later
  }

  function toast(msg, type='info'){
    const el = document.createElement('div');
    el.className='toast';
    el.style.background = type==='win' ? 'linear-gradient(180deg, rgba(20,80,30,0.95), rgba(5,40,10,0.9))' : (type==='loss' ? 'linear-gradient(180deg, rgba(80,20,20,0.95), rgba(40,5,5,0.9))' : 'rgba(0,0,0,0.75)');
    el.style.color = '#fff';
    el.textContent = msg;
    toastWrap.appendChild(el);
    setTimeout(()=>{ el.style.transition='opacity 400ms'; el.style.opacity='0'; setTimeout(()=>el.remove(),450); }, 1800);
  }

  // ====== chart draw ======
  function draw(){
    if(!ctx) return;
    ctx.clearRect(0,0,w,h);
    // layout paddings
    const rightPadding = 80;
    const leftPadding = 12;
    const topPadding = 12;
    const bottomPadding = 36;
    const plotW = w - leftPadding - rightPadding;
    const plotH = h - topPadding - bottomPadding;

    // compute visible slice using scaleX and panOffset
    const count = Math.max(20, Math.round(visibleCount * (1/scaleX)));
    let endIndex = candles.length - panOffset;
    let startIndex = Math.max(0, endIndex - count);
    const arr = candles.slice(startIndex, endIndex);
    if(arr.length === 0) return;

    // price range
    let minP = Infinity, maxP = -Infinity;
    for(const c of arr){ minP = Math.min(minP, c.l); maxP = Math.max(maxP, c.h); }
    const pad = (maxP - minP) * 0.12 || Math.max(0.5, maxP*0.001);
    minP -= pad; maxP += pad;

    // draw horizontal grid lines
    ctx.strokeStyle = 'rgba(255,255,255,0.03)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    for(let i=0;i<5;i++){
      const y = topPadding + (i/4)*plotH;
      ctx.moveTo(leftPadding, y); ctx.lineTo(leftPadding+plotW, y);
    }
    ctx.stroke();

    // draw candles
    const step = plotW / Math.max(1, arr.length);
    const candleW = Math.max(2, Math.min(18, step * 0.6));
    for(let i=0;i<arr.length;i++){
      const c = arr[i];
      const x = leftPadding + i * step + step/2;
      const oy = topPadding + (1 - (c.o - minP)/(maxP-minP)) * plotH;
      const cy = topPadding + (1 - (c.c - minP)/(maxP-minP)) * plotH;
      const hy = topPadding + (1 - (c.h - minP)/(maxP-minP)) * plotH;
      const ly = topPadding + (1 - (c.l - minP)/(maxP-minP)) * plotH;

      // wick
      ctx.strokeStyle = (c.c >= c.o) ? 'rgba(34,197,94,0.95)' : 'rgba(255,107,107,0.95)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(x, hy);
      ctx.lineTo(x, ly);
      ctx.stroke();

      // body
      const top = Math.min(oy, cy);
      const height = Math.max(1, Math.abs(oy-cy));
      if(c.c >= c.o){
        ctx.fillStyle = 'rgba(34,197,94,0.95)';
        ctx.fillRect(x - candleW/2, top, candleW, height);
      } else {
        ctx.fillStyle = 'rgba(255,107,107,0.95)';
        ctx.fillRect(x - candleW/2, top, candleW, height);
      }
    }

    // y-axis labels
    yAxis.innerHTML = '';
    for(let i=0;i<5;i++){
      const val = (maxP - (i/4)*(maxP-minP));
      const node = document.createElement('div');
      node.style.padding = '2px 6px';
      node.style.textAlign = 'right';
      node.textContent = val.toFixed(2);
      yAxis.appendChild(node);
    }

    // draw active bet markers & expiry lines
    for(const b of betList.filter(x=>!x.settled)){
      // find index of candle closest to placedAt inside arr
      const placedIdx = arr.findIndex(c => c.t >= nowFloorMs(b.placedAt, candleDurationSec));
      const i = placedIdx >= 0 ? placedIdx : arr.length-1;
      const x = leftPadding + i * step + step/2;
      // marker
      ctx.fillStyle = (b.dir==='up') ? 'rgba(34,197,94,0.95)' : 'rgba(255,107,107,0.95)';
      ctx.beginPath();
      ctx.arc(x, topPadding + 14, 6, 0, Math.PI*2);
      ctx.fill();

      // expiry vertical line
      const expiryIdx = arr.findIndex(c => c.t >= nowFloorMs(b.expiry, candleDurationSec));
      const xexp = expiryIdx>=0 ? (leftPadding + expiryIdx * step + step/2) : (leftPadding + (arr.length-1) * step + step/2);
      ctx.strokeStyle = 'rgba(255,255,255,0.08)';
      ctx.setLineDash([4,6]);
      ctx.beginPath();
      ctx.moveTo(xexp, topPadding);
      ctx.lineTo(xexp, topPadding + plotH);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    // current price label on right
    ctx.font = '600 12px Inter, sans-serif';
    const pTxt = lastPrice.toFixed(2);
    const txtW = ctx.measureText(pTxt).width;
    const labelW = txtW + 18;
    const labelX = w - rightPadding + 8;
    ctx.fillStyle = 'rgba(255,255,255,0.95)';
    ctx.fillRect(labelX, topPadding + plotH/2 - 14, labelW, 28);
    ctx.fillStyle = '#000';
    ctx.fillText(pTxt, labelX + 9, topPadding + plotH/2 + 5);
  }

  // ====== UI events ======
  document.getElementById('betUp').addEventListener('click', ()=>placeBet('up'));
  document.getElementById('betDown').addEventListener('click', ()=>placeBet('down'));

  // timeframe buttons (1m/2m/5m)
  function setBetTime(sec){
    selectedBetTimeSec = sec;
    document.getElementById('clockBtn').textContent = (sec>=60? (sec/60)+'m' : sec+'s');
    tfButtons.forEach(b => {
      b.classList.remove('active');
      if(parseInt(b.dataset.sec,10) === sec) b.classList.add('active');
    });
  }
  document.getElementById('tf1m').addEventListener('click', ()=>setBetTime(60));
  document.getElementById('tf2m').addEventListener('click', ()=>setBetTime(120));
  document.getElementById('tf5m').addEventListener('click', ()=>setBetTime(300));
  setBetTime(120);

  // zoom with wheel (ctrl+wheel for zoom on desktop; plain wheel pan)
  canvas.addEventListener('wheel', (ev)=>{
    ev.preventDefault();
    // if ctrl pressed, zoom
    if(ev.ctrlKey || ev.metaKey){
      if(ev.deltaY < 0) { scaleX = Math.max(0.4, scaleX * 0.92); }
      else { scaleX = Math.min(3, scaleX * 1.08); }
      // clamp pan
      panOffset = Math.min(panOffset, panMax());
    } else {
      // horizontal wheel or vertical wheel => pan back/forward
      if(ev.deltaY > 0) panOffset = Math.min(panMax(), panOffset + Math.round(Math.abs(ev.deltaY)/60));
      else panOffset = Math.max(0, panOffset - Math.round(Math.abs(ev.deltaY)/60));
    }
    draw();
  }, {passive:false});

  // pointer pan and pinch-to-zoom (supports multiple pointers)
  const pointers = new Map();
  let isPanning=false, lastPanX=0, lastDistance = null;
  canvas.addEventListener('pointerdown', (e)=>{
    canvas.setPointerCapture && canvas.setPointerCapture(e.pointerId);
    pointers.set(e.pointerId, {x:e.clientX, y:e.clientY});
    if(pointers.size === 1){
      isPanning = true;
      lastPanX = e.clientX;
      lastDistance = null;
    } else if(pointers.size === 2){
      // start pinch
      const pts = Array.from(pointers.values());
      lastDistance = Math.hypot(pts[0].x - pts[1].x, pts[0].y - pts[1].y);
    }
  });
  canvas.addEventListener('pointermove', (e)=>{
    if(!pointers.has(e.pointerId)) return;
    pointers.set(e.pointerId, {x:e.clientX, y:e.clientY});
    if(pointers.size === 1 && isPanning){
      const dx = e.clientX - lastPanX;
      lastPanX = e.clientX;
      // convert dx to candle pan (positive dx => move view left => newer => decrease panOffset)
      const panStep = Math.max(1, Math.round(Math.abs(dx) / 8));
      if(dx < 0) panOffset = Math.min(panMax(), panOffset + panStep);
      else panOffset = Math.max(0, panOffset - panStep);
      draw();
    } else if(pointers.size === 2){
      const pts = Array.from(pointers.values());
      const dist = Math.hypot(pts[0].x - pts[1].x, pts[0].y - pts[1].y);
      if(lastDistance){
        const ratio = dist / lastDistance;
        if(ratio > 1.02) scaleX = Math.max(0.4, scaleX * 0.98);
        else if(ratio < 0.98) scaleX = Math.min(3, scaleX * 1.02);
        lastDistance = dist;
        panOffset = Math.min(panOffset, panMax());
        draw();
      } else lastDistance = dist;
    }
  });
  canvas.addEventListener('pointerup', (e)=>{
    pointers.delete(e.pointerId);
    isPanning = pointers.size > 0;
    lastDistance = null;
    try{ canvas.releasePointerCapture && canvas.releasePointerCapture(e.pointerId); }catch(e){}
  });
  canvas.addEventListener('pointercancel', (e)=>{ pointers.delete(e.pointerId); isPanning = pointers.size > 0; lastDistance = null; });

  // quick view controls
  resetViewBtn.addEventListener('click', ()=>{
    scaleX = 1;
    panOffset = 0;
    draw();
  });
  fitRightBtn.addEventListener('click', ()=>{
    panOffset = 0;
    draw();
  });

  // double-tap to go live (mobile)
  let lastTap = 0;
  canvas.addEventListener('touchend', (e)=>{
    const now = Date.now();
    if(now - lastTap < 300){
      panOffset = 0;
      draw();
    }
    lastTap = now;
  }, {passive:true});

  // initial draw & UI
  draw();
  updateUI();

  // expose for debugging
  window._demo = {candles, placeBet, settleBet, draw, toast, betList};

  // bootstrap: produce an immediate tick to show live movement
  produceTick();

})();
</script>
</body>
</html>
